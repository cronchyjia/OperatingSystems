## Virtual-memory page replacement...


This goal requires you to simulate the actions of a virtual-memory subsystem. Specifically you are to take a sequence of logical memory operations generated by a target process and "convert" them into physical addresses. In reality, however, you will not be running a target process but instead using a memory trace generated for you already (using an application suite from Intel called `pin`) and stored into a text file. You are provided with a code skeleton named above (`assign4/virtmem.c`) which currently reads in memory operations contained in a specified trace file and calls the `resolve_address()` function for each operation. This skeleton code also finds a free frame **but does not replace pages when the simulated memory is full.**

Here are the first few lines from a memory trace generated by a "Hello, World!" program:

```
I: 0x7feee195f090
I: 0x7feee195f093
W: 0x7ffe23dd2e88
I: 0x7feee195fea0
W: 0x7ffe23dd2e80
I: 0x7feee195fea1
I: 0x7feee195fea4
W: 0x7ffe23dd2e78
I: 0x7feee195fea6
```

Each line starts with a leading `I`, `W`, or `R` (standing for "instruction read", "memory write", or "memory read" respectively). This single character (and a trailing colon) is followed on the line by a virtual-memory address in hexadecimal. The address must be converted into a physical address, and it is this conversion step -- and much that is needed to make it happen by way of data structures and algorithms -- that your code will simulate.


---

**Three different algorithms to be implemented...**
* to implement a simulation the `FIFO`, `LRU` and `CLOCK` page-replacement algorithms.

Note that `resolve_address()` takes two parameters (the **logical address** and whether the operation on the address **is a read or write**) and returns one value (the physical address).

* The simulator is invoked on the command line when running `virtmem`.
* The algorithm to be used is indicated by a command-line argument 
(`--replace=fifo`, `--replace=lru` or `--replace=clock`).
* The size of a simulated physical frame is indicated at the command line (`--framesize=8` specifies physical frames of size 256 bytes each, i.e., 2^8). Note that the frame size is forced to be a power-of-two.
* The size of the simulated physical memory is indicated at the command line (`--numframes=256` specifies a simulated memory where there are 256 frames). **There is no requirement that the number of frames must be a power-of-two!**
* The file containing the memory trace is indicated at the command line (`--file=hello_out.txt`). These traces are provided to you. (If you are interested in traces from other programs, perhaps the course instructor could make those available, although this would require a exchange of ideas via RocketChat.)
* A progress-bar is enabled via the `--progress` command-line argument.


As an example, `assign4/traces/hello-out.txt` contains a textual
representation of the memory operations generated by running a `hello,
world` command on a x86 virtual machine that I've used. Assuming you
have compiled the skeleton `virtmem.c` within `jhub-cosi`, are running
the program from the `assign4/` directory, and have the trace files
available in `assign4/traces/`, the following will appear (i.e.
skeleton code without FIFO page-replacement yet implemented) where the
frame size is 2^12 bytes in size, where there are 256 such physical
frames, and the progress bar is printed. (The scheme below is
specified as FIFO, but this has no effect in the skeleton code!)

```
./virtmem --file=traces/hello-out.txt --framesize=12 \ 
    --numframes=256 --replace=fifo --progress
```

and here is the output:
```
Progress [............................................................] 100%
Memory references: 127926
Page faults: 119
Swap ins: 119
Swap outs: 0
```

It so happens that the trace above was “simulated to completion”. If we change the number of frames to a smaller number:

```
./virtmem --file=traces/hello-out.txt --framesize=12 \ 
    --numframes=100 --replace=fifo --progress
```

and here is the output for **that** run:

```
Progress [.......................................................     ]  92%
Simulator error: cannot resolve address 0x7fec99b82170 at line 120024
```

The line number message indicates that the simulator attempted to resolve the memory access indicated by line 120024 within `hello-out.txt`, but could not do so. In this case the error results from there no longer existing any more free frames (i.e., the skeleton file does not implement page replacement!).

---

**And a word about "Swap outs" and "Swap ins":**

* When a page is first loaded into a frame (i.e. within a fully-implemented operating systems), the contents of that page are either obtained from the file system (i.e. code for the program, or global variables with initial values also stored in the program’s binary) or the contents of the page are zeroed out (i.e. region of memory corresponding to the page is for uninitialized local and global data). If the physical frame corresponds to a page in which data is stored, then the contents of that page must be stored onto disk if the frame is chosen for replacement; and because we cannot reconstruct the page from the program’s binary, that frame must be stored in swap space. This action of saving a frame’s content onto disk is called a "swap out".
  
* If there is a fault on a particular page, and if that page had previously been mapped to a physical frame, and if that frame had been swapped out, then servicing the page fault must include reading back into the memory the contents of the physical frame as it had been stored within the swap space. This action of loading a frame’s content into disk is called a "swap in". To simplify your logic, you can consider any load of a frame’s contents (including those for code or the first use of initialized global data) as a "swap in".

**You must keep track of the number of swap ins and swap outs that would be required giving the simulations parameters and the addresses that make up the simulation.**



---

**To sum up, you are to...**

* Implement a `FIFO` page replacement scheme and update the appropriate global variables so `output_report()` works.
* Implement an `LRU` page replacement scheme and update the appropriate global variable, ditto comments about `output_report()`.
* Implement a `CLOCK` page replacement scheme and update the appropriate global variable, ditto comments about `output_report()`.
* Keep track of the number of swap-ins and swap-outs.
* Test your implementation with a variety of trace files, frame sizes and memory sizes.
* Make sure your operations work on 64-bit addresses (i.e., long ints). You’ll get weird and hard-to-debug error messages if you depend too much upon 32-bit integers (i.e., regular ints).